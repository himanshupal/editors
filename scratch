import React, { createContext, useContext, useEffect, useMemo, useRef, useState } from 'react'
import { errorMessage, type SupportedLanguagesKey } from '@/constants'
import type { IEditorContext, Tab } from '@/types/context/EditorContext'
import { editor } from 'monaco-editor/esm/vs/editor/editor.api'
import { defaultEditorConfig } from '@/config/editor'
import codeSample from '@/utils/codeSample'

const initialState: IEditorContext = {
	setCurrentModel: () => null,
	createModel: () => null,
	closeModel: () => null,
	currentModel: null,
	previousModel: null,
	// modelQueue: [],
	tabs: [],
	ref: { current: null },
	editorInstance: { current: null },
	editorState: {
		/* No initial state  */
	},
}

const Context = createContext<IEditorContext>(initialState)

const EditorStateProvider = ({ children }: React.PropsWithChildren) => {
	const mountElement = useRef<HTMLDivElement | null>(null)
	const editorInstance = useRef<editor.IStandaloneCodeEditor | null>(null)

	const [currentModel, setCurrentModel] = useState<editor.ITextModel | null>(null)
	const [previousModel, setPreviousModel] = useState<editor.ITextModel | null>(null)
	const [tabs, setTabs] = useState<Array<Tab>>(editor.getModels().map(({ id }) => ({ id, title: id })))
	const [editorState, setEditorState] = useState<Record<string, editor.ICodeEditorViewState | null>>({})

	useEffect(() => {
		if (!mountElement.current) return
		editorInstance.current = editor.create(mountElement.current, defaultEditorConfig)
		const defaultModels = editor.getModels()
		if (defaultModels.length) changeModelTo(defaultModels[0])
		const onCreateListener = editor.onDidCreateModel((model) => {
			if (!editorInstance.current) return console.debug(errorMessage.noEditor)
			changeModelTo(model)
			setTabs((t) => [
				...t,
				{
					id: model.id,
					title: model.id,
				},
			])
		})
		function callback() {
			onCreateListener.dispose()
			editorInstance.current?.dispose()
		}
		return callback
	}, [mountElement.current])

	useEffect(() => {
		if (!editorInstance.current) return console.debug(errorMessage.noEditor)
		console.debug(`editorInstance updated`)
		window.editorInstance = editorInstance.current
	}, [editorInstance.current])

	useEffect(() => {
		if (!editorInstance.current) return console.debug(errorMessage.noEditor)
		editorInstance.current.setModel(currentModel)
		if (currentModel && currentModel.id in editorState) {
			editorInstance.current.restoreViewState(editorState[currentModel.id])
			editorInstance.current.focus()
		}
	}, [currentModel])

	const changeModelTo = (model: editor.ITextModel | null) => {
		if (currentModel) {
			setPreviousModel(currentModel)
			setEditorState((s) => {
				if (!editorInstance.current) {
					return console.debug(errorMessage.noEditor), s
				}
				return {
					...s,
					[currentModel.id]: editorInstance.current.saveViewState(),
				}
			})
		}
		setCurrentModel(model)
	}

	const newTab = (language?: SupportedLanguagesKey) => {
		if (language === null) return
		if (!editorInstance.current) return console.debug(errorMessage.noEditor)

		const newModel = editor.createModel((language && codeSample[language]) || '', language)
		changeModelTo(newModel)
	}

	const setActiveTab = (id: string) => {
		const currentModel = editor.getModels().find((m) => m.id === id)
		if (!currentModel) return console.debug(errorMessage.noModel)
		changeModelTo(currentModel)
	}

	const closeTab = (id: string) => {
		const models = editor.getModels()
		const selectedModel = models.find((m) => m.id === id)
		if (!selectedModel) return console.debug(errorMessage.noModel)
		if (selectedModel.id in editorState) delete editorState[selectedModel.id]
		selectedModel.dispose()
		setTabs((t) => t.filter(({ id: mId }) => mId !== id))
		if (id !== currentModel?.id) return
		const [otherModel] = models.length - 1 ? models.slice(-1) : [null]
		changeModelTo(!previousModel || previousModel.isDisposed() ? otherModel : previousModel)
	}

	return (
		<Context.Provider
			value={{
				ref: mountElement,
				editorInstance,
				previousModel,
				// modelQueue,
				closeModel: closeTab,
				createModel: newTab,
				editorState,
				currentModel,
				setCurrentModel: setActiveTab,
				tabs /* : useMemo(() => modelQueue.map(({ id }) => ({ id, title: id })), [modelQueue]) */,
			}}
		>
			{children}
		</Context.Provider>
	)
}

export const useEditorContext = () => useContext(Context)

export default EditorStateProvider

/* *********************** TYPES BELOW THIS - MOVE TO ANOTHER FILE *********************** */

import type { SupportedLanguagesKey } from '@/constants'
import type { editor } from 'monaco-editor'

export interface Tab {
	id: string
	title: string
}

export interface IEditorContext {
	currentModel: editor.ITextModel | null
	previousModel: editor.ITextModel | null
	// modelQueue: editor.ITextModel[];
	ref: React.MutableRefObject<HTMLDivElement | null>
	editorInstance: React.MutableRefObject<editor.IStandaloneCodeEditor | null>
	tabs: Tab[]
	editorState: {
		[modelId: string]: editor.ICodeEditorViewState | null
	}

	createModel(language: SupportedLanguagesKey): void
	setCurrentModel(id: string): void
	closeModel(id: string): void
}
